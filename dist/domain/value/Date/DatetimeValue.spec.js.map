{"version":3,"sources":["../../../../src/domain/value/Date/DatetimeValue.spec.ts"],"sourcesContent":["import { format } from 'date-fns';\nimport fc from 'fast-check';\nimport { describe, expect, it } from 'vitest';\n\nimport { DATETIME_VALUE_FORMAT, DatetimeValue } from './DatetimeValue';\n\ndescribe('DatetimeValue', () => {\n  it('should return DatetimeValue when input valid', () => {\n    fc.assert(\n      fc.property(\n        fc\n          .record({\n            date: fc.date({\n              min: new Date(2000, 12, 31, 24, 60, 60),\n              max: new Date(4000, 12, 31, 24, 60, 60),\n            }),\n          })\n          .map(({ date }) => {\n            return {\n              date: format(date, DATETIME_VALUE_FORMAT),\n            };\n          }),\n        ({ date }) => {\n          const ymdhms = date.split(' ', 2);\n          const [hour, minute, second] = ymdhms[1].split(':', 3);\n\n          const value = DatetimeValue.from(date);\n\n          expect(value).toBeInstanceOf(DatetimeValue);\n          expect(value.hour).toEqual(Number(hour));\n          expect(value.minute).toEqual(Number(minute));\n          expect(value.second).toEqual(Number(second));\n          expect(value.toString()).toEqual(date);\n        },\n      ),\n    );\n  });\n  it('should throw invalid YearMonthDay exception when input invalid YearMonthDay', () => {\n    fc.assert(\n      fc.property(fc.integer({ min: 1, max: 3 }), (year) => {\n        expect(() => DatetimeValue.from(`${year}-01-01 10:20:23`)).toThrow(\n          /Invalid YearMonthDay/,\n        );\n      }),\n    );\n  });\n  it('should throw invalid hour exception when input invalid hour', () => {\n    fc.assert(\n      fc.property(fc.integer({ min: 25, max: 50 }), (hour) => {\n        expect(() => DatetimeValue.from(`2024-11-01 ${hour}:20:23`)).toThrow(\n          /Invalid Hour/,\n        );\n      }),\n    );\n  });\n  it('should throw invalid minute exception when input invalid minute', () => {\n    fc.assert(\n      fc.property(fc.integer({ min: 61, max: 90 }), (minute) => {\n        expect(() => DatetimeValue.from(`2024-11-01 10:${minute}:23`)).toThrow(\n          /Invalid Minute/,\n        );\n      }),\n    );\n  });\n  it('should throw invalid second exception when input invalid second', () => {\n    fc.assert(\n      fc.property(fc.integer({ min: 61, max: 90 }), (second) => {\n        expect(() => DatetimeValue.from(`2024-11-01 10:20:${second}`)).toThrow(\n          /Invalid Second/,\n        );\n      }),\n    );\n  });\n  it('should return true when call equals function with two DatetimeValue has same value', () => {\n    fc.assert(\n      fc.property(\n        fc\n          .record({\n            date: fc.date({\n              min: new Date(2000, 12, 31, 24, 60, 60),\n              max: new Date(4000, 12, 31, 24, 60, 60),\n            }),\n          })\n          .map(({ date }) => ({\n            date: format(date, DATETIME_VALUE_FORMAT),\n          })),\n        ({ date }) => {\n          const value1 = DatetimeValue.from(date);\n          const value2 = DatetimeValue.from(date);\n\n          expect(value1).toBeInstanceOf(DatetimeValue);\n          expect(value2).toBeInstanceOf(DatetimeValue);\n\n          expect(value1.toString()).toEqual(date);\n          expect(value2.toString()).toEqual(date);\n\n          expect(value1.equals(value2)).toBe(true);\n        },\n      ),\n    );\n  });\n});\n"],"names":["format","fc","describe","expect","it","DATETIME_VALUE_FORMAT","DatetimeValue","assert","property","record","date","min","Date","max","map","ymdhms","split","hour","minute","second","value","from","toBeInstanceOf","toEqual","Number","toString","integer","year","toThrow","value1","value2","equals","toBe"],"mappings":"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"}